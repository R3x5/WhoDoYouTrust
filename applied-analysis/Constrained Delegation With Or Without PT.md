#### ***This write-up applies the identity-continuity and ticket-capability semantics discussed in the protocol analysis notes to a real-world Active Directory environment.***



Under normal circumstances, delegation is not overly difficult to understand, yet there are still noteworthy aspects to highlight. Next, I will reference a machine from **HackTheBox**, [Rebound](https://app.hackthebox.com/machines/Rebound), to illustrate this. The content is cited from [0xdf](https://0xdf.gitlab.io/).

Link: https://0xdf.gitlab.io/2024/03/30/htb-rebound.html#shell-as-administrator

```bash
oxdf@hacky$ findDelegation.py 'rebound.htb/delegator$' -dc-ip 10.10.11.231 -k -hashes :E1630B0E18242439A50E9D8B5F5B7524 
Impacket v0.12.0.dev1+20240308.164415.4a62f39 - Copyright 2023 Fortra 
[*] Getting machine hostname 
[-] CCache file is not found. Skipping... 
[-] CCache file is not found. Skipping... 
AccountName   AccountType                     DelegationType  DelegationRightsTo
---------- ----------------------------------- -------------- --------------------
delegator$  ms-DS-Group-Managed-Service-Account Constrained   http/dc01.rebound.htb
```

The article provides an explanation of constrained delegation and proceeds to attempt a certain command. The result as expected was a failure. The author attributes this failure to the absence of the `forwardable`flag.

```bash
getST.py -spn http/dc01.rebound.htb -impersonate administrator 'rebound.htb/delegator$' -hashes :E1630B0E18242439A50E9D8B5F5B7524
# ...   omitted
[-] Kerberos SessionError: KDC_ERR_BADOPTION(KDC cannot accommodate requested option) 
[-] Probably SPN is not allowed to delegate by user delegator$ or initial TGT not forwardable
```

> It is using S4U2Self to get a ticket for the administrator user for `delegator$`, and then trying to use S4U2Proxy to forward it, but it doesn’t work. The `-self` flag tells `getST.py` to stop after the S4U2Self, getting a ticket for administrator for delegator$. The resulting ticket is missing the forwardable flag
> 
> Link: https://0xdf.gitlab.io/2024/03/30/htb-rebound.html#constrained-delegation


The constrained delegation for `delegator$`does exist, but it is configured as Kerberos Constrained Delegation (KCD) without Protocol Transition. Therefore, an attacker cannot arbitrarily forge a user identity to utilize this delegation chain. In other words, it can only forward an existing and forwardable user ticket, which the attacker does not possess.

The ticket generated by S4U2Self is marked as `forwardable`only when Protocol Transition (PT) is enabled. Otherwise, a `non-forwardable`service ticket is produced, which cannot be used for S4U2Proxy.

The sole hard requirement for S4U2Proxy is that the input ticket must carry the `forwardable`flag (see [asktgs](https://github.com/R3x5/WhoDoYouTrust/blob/main/protocol-semantics/asktgs.md)). In the current environment, without PT, the ticket obtained via S4U2Self is _not_ forwardable, consequently guaranteeing the failure of S4U2Proxy.

In the Kerberos semantics discussed earlier, the forwardable flag represents
whether an access capability is allowed to propagate across service
boundaries without ***re-establishing identity***.

**I will explain this point with a very straightforward way, using the execution of a command as follows:**

```bash
getST.py -impersonate administrator rebound.htb/delegator$
```

This step triggers:

```
delegator$ → S4U2Self → KDC
```

The key point is that `delegator$`does not receive a genuine user ticket from `Administrator → delegator$`as input. Consequently, the KDC can only return a synthetic and non-forwardable Service Ticket (see [asktgt](https://github.com/R3x5/WhoDoYouTrust/blob/main/protocol-semantics/asktgt.md)). It's worth noting that this behavior is mandated by the Kerberos specification.


### What if PT enabled?

**Because S4U2Self without Protocol Transition does not establish *identity continuity* for a real user principal, the KDC is forced to issue a `non-forwardable`, synthetic service ticket.**

If enabled, the process is like this, and **the previously described attack would become viable!**

```
S4U2Self (forwardable) → S4U2Proxy → Administrator → HTTP/dc01
```

_The following diagram illustrates the permitted S4U2Self → S4U2Proxy flow when Protocol Transition is enabled, as commonly presented in training materials (e.g. [CRTE](https://www.alteredsecurity.com/redteamlab))._

![img](/Images/KCD_with_PT.png)
> This is the canonical delegation flow taught in advanced AD courses (e.g. [CRTE](https://www.alteredsecurity.com/redteamlab)), which implicitly assumes Protocol Transition is enabled.


In this case, the KDC is explicitly allowed to issue a *forwardable* service ticket during S4U2Self, enabling capability propagation across service boundaries (see [asktgt](https://github.com/R3x5/WhoDoYouTrust/blob/main/protocol-semantics/asktgt.md), [asktgs](https://github.com/R3x5/WhoDoYouTrust/blob/main/protocol-semantics/asktgs.md)).

### Additionally, there is a point that many people often confuse:

# FAQ

#### **Q**: The previous discussion frequently involves Kerberos authentication. So, what exactly is Kerberos authentication?

**A**:​ The client uses the Kerberos protocol to prove to the KDC that it possesses the long-term key of a specific principal, and the KDC issues tickets accordingly. The key point is that, for example, using AS-REQ, AS-REP, TGS-REQ, and TGS-REP, the authentication material is the Kerberos key, and the KDC participates in the process and makes the security decision.

#### **Q**: Why is NTLM not considered Kerberos?

**A:** Because it is a completely independent challenge-response authentication protocol. It does not require a KDC and does not produce Kerberos tickets. Therefore, NTLM is not equivalent to Kerberos.

#### **Q**:​ NTLM can be used for Overpass-the-Hash (OPTH) to request tickets. Using tickets means it's Kerberos authentication, right?

**A**:​ Assume an attacker uses an NTLM hash to impersonate a client and initiates an AS-REQ to the KDC. This means the attacker is not using the NTLM protocol but is directly interacting with the KDC. Therefore, from the KDC's perspective, the OPTH request represents **100%** legitimate Kerberos authentication, because Kerberos does not care _how_ you obtained the key; it only cares whether you can use it to prove your identity.
